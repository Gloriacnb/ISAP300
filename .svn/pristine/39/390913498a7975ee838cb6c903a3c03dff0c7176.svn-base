/*
 * MidWatchDog.cpp
 *
 *  Created on: 2013-7-24
 *      Author: Administrator
 */

#include "MidWatchDog.h"
#include "lpc32xx_wdt_driver.h"
#include "lpc32xx_clkpwr_driver.h"
#include "os.h"
#include "GeneralLogic.h"

int MidWatchDog::w = none;
int MidWatchDog::wdtdev;
static WDT_SETUP_T wdtsetup;
TASK void T_WDT(void);

static uint8 testWTD = 0;

MidWatchDog::MidWatchDog() {
	// TODO Auto-generated constructor stub

}

MidWatchDog::~MidWatchDog() {
	// TODO Auto-generated destructor stub
}


void MidWatchDog::WatchDogInitial(void) {
//    ChipWDInitial();
    w = offchip;
    os_tsk_create(T_WDT, P_WDT);
}
void MidWatchDog::feed(void) {
//	wdt_ioctl(wdtdev, WDT_COUNTER_WRITE, 0);
    GeneralLogic::instance().feedWTD();

}
void MidWatchDog::start(void) {
//	wdt_ioctl(wdtdev, WDT_TIMER_CONTROL, WDT_TIMER_GO);
    GeneralLogic::instance().startWTD();
}
void MidWatchDog::stop(void) {
//	wdt_ioctl(wdtdev, WDT_TIMER_CONTROL, WDT_TIMER_STOP);
    GeneralLogic::instance().stopWTD();
}
void MidWatchDog::pass(uint8 v) {
    testWTD = v;
}


void MidWatchDog::ChipWDInitial(void) {

	/* Enable simple WDT clock */
	clkpwr_clk_en_dis(CLKPWR_WDOG_CLK, 1);

	wdtdev = wdt_open(WDT, 0);
	if( wdtdev == 0 ) {
		return;
	}
	wdt_ioctl(wdtdev, WDT_COUNTER_WRITE, 0);
	wdtsetup.initial_setup = TRUE;
	wdtsetup.pause = 1;
	wdtsetup.resfrc2 = 0;
	wdtsetup.resfrc1 = 0;
	wdtsetup.m_res2 = 0;
	wdtsetup.m_res1 = 1;
	wdtsetup.ext_match_setup = WDT_EXT_MATCH_HIGH;
	wdtsetup.match_setup = WDT_MATCH_EN_INT_RESET;
	wdtsetup.match0 = 3000 * 13000; //13000 = 1ms
	wdtsetup.match0_update = TRUE;
	wdtsetup.counter_update = FALSE;
	wdtsetup.pulse_update = FALSE;
	wdt_ioctl(wdtdev, WDT_SETUP, (UNS_32) &wdtsetup);
}

void MidWatchDog::ExtWDInitial(void) {

}


TASK void T_WDT(void) {
    MidWatchDog::start();
    while( 1 ) {
        os_dly_wait(100);
        if( testWTD == 0 ) {
            MidWatchDog::feed();
        }
    }
}
