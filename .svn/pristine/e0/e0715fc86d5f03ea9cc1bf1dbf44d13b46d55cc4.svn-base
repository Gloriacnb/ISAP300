/*
 * InnerDCCManager.cpp
 *
 *  Created on: 2013-7-1
 *      Author: Administrator
 */

#include "InnerDCCManager.h"
#include "UID.h"
#include "SwitchPortInner.h"
#include "DCCChannelSnd.h"
#include "DCCChannelRcv.h"
#include <stdio.h>
#include "SoftSwitch_define.h"
#include "os.h"
#include "GeneralLogic.h"
#include "bsp_interrupt.h"
#include <iostream>

static const char* fname = "InnerDccInfo2_7_20.cfg";
TASK void rcvInnerNmPaket(void);
extern "C" INTR_HANDLER void IntHandler_DCC(void);

InnerDCCManager InnerDCCManager::dccmng;
//std::vector<Inner_Port_Config> InnerDCCManager::configData;
std::list<DCCChannelRcv*> ch_have_packet;

OS_TID t_dcc_rcv = 0;
OS_TID t_dcc_process;
OS_SEM sem_dcc_nm;

InnerDCCManager::InnerDCCManager() {

}

InnerDCCManager::~InnerDCCManager() {
	// TODO Auto-generated destructor stub
}


/*
 * �ָ�Ĭ�����ã�ֻ��һ���ڲ��ӿڣ����й��DCC
 */
void InnerDCCManager::RestoreDefaultConfig() {

	Inner_Port_Config temp = {0};
	ST_NM_Channel info = {0};
	for( int slot = 0; slot < 2; slot++ ) {
        info.slot = slot;
	    for( int ch = 0; ch < 2; ch++ ) {
	        info.subtype = subtype_dcc;
	        info.sn = ch;
	        temp.ch_index = UID::makeUID(&info);
	        temp.ch_type = nm_ch_type_rcv;
	        temp.port_index = Inner_Port1_Sn;
	        configData.push_back(temp);
	        temp.ch_type = nm_ch_type_snd;
	        configData.push_back(temp);
	    }
	    for (int i = 0; i < 4; ++i) {
            info.subtype = subtype_sabit;
            info.sn = i;
            temp.ch_index = UID::makeUID(&info);
            temp.ch_type = nm_ch_type_rcv;
            temp.port_index = Inner_Port1_Sn + 1 + i;
            configData.push_back(temp);
            temp.ch_type = nm_ch_type_snd;
            configData.push_back(temp);
        }
	}
    for( int slot = 2; slot < 7; slot++ ) {
        info.slot = slot;
        for( int ch = 0; ch < 16; ch++ ) {
            info.subtype = subtype_sabit;
            info.sn = ch;
            temp.ch_index = UID::makeUID(&info);
            temp.ch_type = nm_ch_type_rcv;
            temp.port_index = slot*16 + ch;
            configData.push_back(temp);
            temp.ch_type = nm_ch_type_snd;
            configData.push_back(temp);
        }
        for (int ch = 0; ch < 8; ++ch) {
            info.subtype = subtype_dcc;
            info.sn = ch;
            temp.ch_index = UID::makeUID(&info);
            temp.ch_type = nm_ch_type_rcv;
            temp.port_index = slot*16 + ch;
            configData.push_back(temp);
            temp.ch_type = nm_ch_type_snd;
            configData.push_back(temp);
        }
    }
    saveConfig();
}


bool InnerDCCManager::saveConfig(void) {
    FILE* f = fopen(fname, "wb");
    if( f ) {
        for( int i = 0; i < configData.size(); i++ ) {
            fwrite(&configData[i], sizeof(Inner_Port_Config), 1, f);
        }
        fclose(f);
        return true;
    }
    return false;
}


bool InnerDCCManager::fetchConfig(void) {
    FILE* f = fopen(fname, "rb");
    if( f ) {
        Inner_Port_Config temp;
        while( fread(&temp, sizeof(Inner_Port_Config), 1, f) ) {
            configData.push_back(temp);
        }
        fclose(f);
        return true;
    }
    return false;
}

/*
 * �����ڲ�����ͨ����ʼ��ʱ������ô˺���
 * ����ڲ�����ӿ��������д�ͨ�����򼤻�ʹ��
 */
void InnerDCCManager::join(DCCChannelSnd* ch, uint8 portid) {
    if( ch == 0 ) {
        return;
    }
    int innerPort = -1;
    if( portid == 0 ) {
        innerPort = getBelongInnerPort(ch);
    }
    else {
        innerPort = portid;
    }
    if( innerPort < 0 ) {
        return;
    }
    SwitchPortInner* p = (SwitchPortInner*)SwitchPort::getSwitchPort(innerPort);
    if( p == 0 ) {
        p = new SwitchPortInner(innerPort);
    }
    if( p ) {
        stop();
        p->addDcc(ch);
        start(false);
    }
    return;
}

void InnerDCCManager::join(DCCChannelRcv* ch, uint8 portid) {
    if( ch == 0 ) {
        return;
    }
    int innerPort = -1;
    if( portid == 0 ) {
        innerPort = getBelongInnerPort(ch);
    }
    else {
        innerPort = portid;
    }
    if( innerPort < 0 ) {
        return;
    }
    SwitchPortInner* p = (SwitchPortInner*)SwitchPort::getSwitchPort(innerPort);
    if( !p ) {
        p = new SwitchPortInner(innerPort);
    }
    if( p ) {
        stop();
        p->addDcc(ch);
        start(false);
    }
    return;

}

void InnerDCCManager::leave(DCCChannelSnd* ch) {
    if( ch == 0 ) {
        return;
    }
//    int innerPort = getBelongInnerPort(ch);
    SwitchPortInner* p = ch->getInnerPort();//(SwitchPortInner*)SwitchPort::getSwitchPort(innerPort);
    if( !p ) {
        return;
    }
    stop();
    p->removeDcc(ch);
    if( p->dccRcv.size() == 0 && p->dccSnd.size() == 0 ) {
        delete p;
    }
    start(false);
    return;
}

void InnerDCCManager::leave(DCCChannelRcv* ch) {
    if( ch == 0 ) {
        return;
    }
    SwitchPortInner* p = ch->getInnerPort();
    if( p == 0 ) {
        return;
    }
    stop();
    p->removeDcc(ch);
    if( p->dccRcv.size() == 0 && p->dccSnd.size() == 0 ) {
        delete p;
    }
    start(false);
}

void InnerDCCManager::start(bool first) {
    if( first ) {
        if( !fetchConfig() ) {
            RestoreDefaultConfig();
        }
        SIC_2_Enable();
        os_sem_init(sem_dcc_nm, 0);
        t_dcc_rcv = os_tsk_create(rcvInnerNmPaket,P_DCC_RCV);
    }
    Dcc_interrupt_enable();
}

void InnerDCCManager::stop(bool end) {
    if( end ) {
        os_tsk_delete(t_dcc_rcv);
    }
    Dcc_interrupt_disable();
}

int InnerDCCManager::getBelongInnerPort(DCCChannelSnd* ch) {
    if( ch ) {
        for( int i = 0; i < configData.size(); i++ ) {
            if( configData[i].ch_type == nm_ch_type_snd &&
                    configData[i].ch_index == ch->getUID() ) {
                return configData[i].port_index;
            }
        }
    }
    return -1;
}
int InnerDCCManager::getBelongInnerPort(DCCChannelRcv* ch) {
    if( ch ) {
        for( int i = 0; i < configData.size(); i++ ) {
            if( configData[i].ch_type == nm_ch_type_rcv &&
                    configData[i].ch_index == ch->getUID() ) {
                return configData[i].port_index;
            }
        }
    }
    return -1;
}

void InnerDCCManager::processRemoteDevice(uint8* p, DCCChannelRcv* ch) {
    static uint8 NM_PORT = 10;
    if( p == 0 || ch == 0 ) {
#ifdef EZ_DEBUG
        printf("\n!!!InnerDCCManager::processRemoteDevice Error para\n!!!");
#endif
        return;
    }
    SwitchPortInner* port = ch->getInnerPort();
    if( port == 0 ) {
#ifdef EZ_DEBUG
        printf("\n!!!InnerDCCManager::processRemoteDevice Error para\n!!!");
#endif
        return;
    }
    DCCChannelSnd* sch = DCCChannelSnd::getSendDccByUID(ch->getUID());
    if( sch == 0 ) {
#ifdef EZ_DEBUG
        printf("\n!!!InnerDCCManager::processRemoteDevice Error para\n!!!");
#endif
        return;
    }
    uint32 netIP = (p[0] << 24) |
            (p[1] << 16) |
            (p[2] <<  8) |
            (p[3] <<  0) ;
    std::map<uint32, uint32>::iterator it = DevicePool.find(netIP);
    if( it != DevicePool.end() ) {
        //加入一个ch
        if( port->getPortSn() != it->first ) {
            leave(ch);
            leave(sch);
            //ch 加入新的port
            join(ch, it->second);
            join(sch, it->second);
        }
        else {
#ifdef EZ_DEBUG
        printf("\n!!!do nothing\n!!!");
#endif
           return; //已在该port中，不需做任何操作
        }
    }
    else {//新的记录
        leave(ch);
        leave(sch);
        //ch 加入新的port
        join(ch, NM_PORT);
        join(sch, NM_PORT);
        DevicePool.insert(std::pair<uint32, uint32>(netIP, NM_PORT++) );
    }
}


TASK void rcvInnerNmPaket(void) {
    while(1) {
        os_evt_wait_or(0x0001, 0xffff);

        /*��ѯ����ͨ���հ�*/
        bool result = false;
        DCCChannelRcv* ch = DCCChannelRcv::getFirstRcvDcc();
        while( ch != 0 ) {
            result |= ch->receivData();
            ch = DCCChannelRcv::getNextRcvDcc(ch->getUID());
        }

        /*��ѯ��ɺ���ж�*/
        if( !result ) {
            printf("\n!!!No DCCChannelRcv, please reset device!!!\n");
        }
        InnerDCCManager::instance().start();

    }
}


INTR_HANDLER void IntHandler_DCC(void)  {
    /* �������жϴ�������е����κ��漰EZ BUS�ĺ��� */
    InnerDCCManager::instance().stop();
    isr_evt_set(0x0001, t_dcc_rcv);
}
